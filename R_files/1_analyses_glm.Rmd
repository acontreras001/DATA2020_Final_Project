---
title: "Data Analysis"
output: pdf_document
---

# Introduction
This document provides an overview of the analyses conducted on the project dataset.

## Dependency Setup
```{r Dependency Setup, inlcude = TRUE}

if (!require("here")) install.packages("here")
library(here)

# Set current working directory to file location
setwd(here::here())

#Print current working directory in case not connected to .Rproj file
print(getwd())

# Define the path to the .renv lockfile within the 'renv' folder
renv_lockfile <- file.path(getwd(), "renv.lock")

# Activate and restore packages from renv lock file
if (!require("renv")) install.packages("renv")
renv::restore()

# Use the p_load function to install and load any desired packages that may not 
# have been in the renv.lock file. Note, if the packages were already in the 
# renv.lock file, that is okay. `p_load` will not change version number

if (!require("pacman")) install.packages("pacman")
pacman::p_load(renv, rmarkdown,  knitr, tidyverse, reshape2, stargazer, GGally,
               readr, haven, gridExtra, broom, car, caret, Metrics)

# Update the renv lock file
renv::snapshot()
```

```{r}
df <- readr::read_csv("data/processed/EDA_output.csv")

#Load custom functions
#source("R_files/functions_analyses.R")

output_directory <- file.path(getwd(), "outputs/analysis_glm")
```


```{r}

# Remove participant_id variable
df <- df %>% 
  select(-participant_id)


numeric_vars <- c("father_age", "mother_age", "household_income_pre_tax")
binary_vars <- c("father_married_to_mother", "father_living_with_mother", "mother_part_labor_union", "mother_part_community_org", 
                 "mother_part_children_group", "mother_political_demonstration", "father_vote_nov2020", "mother_vote_nov2020",
                "father_par_labor_union", "father_par_community_org", "father_par_children_group", "father_political_demonstration")
#multi_categorical_vars <- c("current_housing_situation", "mother_current_employment_status", "father_current_employment_status")
multi_categorical_vars <- c()
race_vars <- c("race_category", "hispanic_origin")

```

# Check for correlation in numeric variables

```{r}
# Check for linearity in the numeric variables

p <- GGally::ggpairs(df[, numeric_vars],
                     lower = list(continuous = wrap("points", color = "blue", alpha = 0.5)),
                     upper = list(continuous = wrap("cor", size = 4)),
                     diag = list(continuous = wrap("barDiag")),
                     axisLabels = "show",
                     progress = FALSE) +
  theme_bw() +  
  theme(text = element_text(size = 12), panel.spacing = unit(2, "lines"))  


ggsave(paste0(output_directory, "/numeric_vars_corr_comp", ".png"), plot = p, width = 10, height = 8, dpi = 300)


```

```{r}
# # Apply z-score normalization
# 
# df <- df %>%
#   mutate(across(c("father_age", "mother_age", "household_income_pre_tax"),
#                 ~(. - mean(.)) / sd(.),
#                 .names = "{col}"))
# 
# norm_numeric_vars <- c("norm_father_age", "norm_mother_age", "norm_household_income_pre_tax")
# 
# 
# GGally::ggpairs(df[, norm_numeric_vars],
#         lower = list(continuous = wrap("points", color = "blue", alpha = 0.5)),
#         upper = list(continuous = wrap("cor", size = 4)),
#         diag = list(continuous = wrap("barDiag")),
#         axisLabels = "show",
#         progress = FALSE) +
#   theme_bw() + 
#   theme(text = element_text(size = 12), panel.spacing = unit(2, "lines")) 

```

```{r}

# Prepare the numeric data and calculate correlations
numeric_data <- df[, numeric_vars]
numeric_cor <- cor(numeric_data)
melted_numeric_cor <- melt(numeric_cor)

# Filter for lower triangle of the matrix including the diagonal
melted_numeric_cor <- melted_numeric_cor[lower.tri(numeric_cor, diag = TRUE), ]

# Plotting the correlation matrix with values
p <- ggplot(melted_numeric_cor, aes(x = Var1, y = Var2, fill = value)) + 
  geom_tile(color = "white") +
  geom_text(aes(label = sprintf("%.3f", value)), vjust = .5, color = "black") +
  scale_fill_gradient2(low = "blue", high = "red", mid = "white", midpoint = 0) +
  theme_minimal() +
  labs(title = "Correlation of Numeric Variables", x = NULL, y = NULL) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

ggsave(paste0(output_directory, "/numeric_vars_corr_simple", ".png"), plot = p, width = 10, height = 8, dpi = 300)

```

# Check for correlation in binary variables

```{r}
binary_data <- df[, binary_vars]

# Calculate correlations
binary_cor <- cor(binary_data)
melted_binary_cor <- melt(binary_cor)
melted_binary_cor <- melted_binary_cor[lower.tri(binary_cor, diag = TRUE), ]

# Plotting the correlation matrix with values
p <- ggplot(melted_binary_cor, aes(x = Var1, y = Var2, fill = value)) + 
  geom_tile(color = "white") +
  geom_text(aes(label = sprintf("%.2f", value)), vjust = 1.5, color = "black") +
  scale_fill_gradient2(low = "blue", high = "red", mid = "white", midpoint = 0) +
  theme_minimal() +
  labs(title = "Correlation of Binary Variables", x = NULL, y = NULL) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

ggsave(paste0(output_directory, "/binary_data_corr", ".png"), plot = p, width = 10, height = 8, dpi = 300)


```

# Check for correlation in multi-categorical variables

```{r}
# # Convert multi-categorical variables to dummy variables
# multi_cat_data <- data.frame(model.matrix(~ current_housing_situation + mother_current_employment_status + 
#                                               father_current_employment_status - 1, data = df))
# 
# # Calculate correlations
# multi_cat_cor <- cor(multi_cat_data)
# melted_multi_cat_cor <- melt(multi_cat_cor)
# melted_multi_cat_cor <- melted_multi_cat_cor[lower.tri(multi_cat_cor, diag = TRUE), ]
# 
# # Plotting the correlation matrix with values
# p <- ggplot(melted_multi_cat_cor, aes(x = Var1, y = Var2, fill = value)) + 
#   geom_tile(color = "white") +
#   geom_text(aes(label = sprintf("%.2f", value)), vjust = 1.5, color = "black") +
#   scale_fill_gradient2(low = "blue", high = "red", mid = "white", midpoint = 0) +
#   theme_minimal() +
#   labs(title = "Correlation of Multi-Categorical Variables", x = NULL, y = NULL) +
#   theme(axis.text.x = element_text(angle = 45, hjust = 1))
# 
# ggsave(paste0(output_directory, "/multi_cat_data_corr", ".png"), plot = p, width = 10, height = 8, dpi = 300)


```

# Create General Linear Model

```{r}
# Formula for  GLM
create_glm_formula <- function(dependent_var, independent_vars) {
  formula_str <- paste(dependent_var, "~", paste(independent_vars, collapse = " + "))
  as.formula(formula_str)
}

# Dataframe for  GLM
create_glm_df <- function(df, dep_var, indep_vars) {
  glm_vars <- c(dep_var, indep_vars)
  df %>% select(all_of(glm_vars)) %>% drop_na()
}

# Function to create calibration plot
create_calibration_plot <- function(data, dep_var, output_file) {
  # Convert dep_var to actual data column in the dataframe
  data$dep_var_actual <- data[[dep_var]]

  # Calculate metrics
  calibration_data <- data %>%
    mutate(prob_bin = cut(predicted_prob, breaks = seq(0, 1, by = 0.1), include.lowest = TRUE, right = FALSE)) %>%
    group_by(prob_bin) %>%
    summarise(
      Avg_Predicted = mean(predicted_prob),
      Avg_Actual = mean(dep_var_actual, na.rm = TRUE),  # Ensure numeric calculation
      N = n(),
      SE = sqrt(Avg_Actual * (1 - Avg_Actual) / N),
      Lower_CI = Avg_Actual - 1.96 * SE,
      Upper_CI = Avg_Actual + 1.96 * SE
    ) %>%
    ggplot(aes(x = Avg_Predicted, y = Avg_Actual)) +
      geom_point() +
      geom_errorbar(aes(ymin = Lower_CI, ymax = Upper_CI), width = 0.02) +
      xlim(0, 1) +
      ylim(0, 1) +
      labs(x = "Average Predicted Probability", y = "Average Observed Outcome", title = "Calibration Plot") +
      geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "red") +
      theme_gray()

  ggsave(filename = output_file, plot = calibration_data, width = 20, height = 16, units = "cm")
}


```

```{r}

dep_var <- "father_vote_nov2020"
all_vars <- c(numeric_vars, binary_vars, multi_categorical_vars, race_vars) # define these variables as needed
indep_vars <- setdiff(all_vars, dep_var)

# Create the GLM 
glm_formula <- create_glm_formula(dep_var, indep_vars)
glm_df <- create_glm_df(df, dep_var, indep_vars)

general_linear_model <- glm(formula = glm_formula, family = binomial(), data = glm_df, control = list(maxit = 1000))

glm_df$predicted_prob <- predict(general_linear_model, type = "response")

# Calibration plot

output_file <- file.path(getwd(), "outputs/analysis_glm/calibration_plot.png")
create_calibration_plot(glm_df, dep_var, output_file)

summary(general_linear_model)

```


```{r}
# Predicted class labels
threshold <- 0.5
predicted_labels <- ifelse(glm_df$predicted_prob > threshold, 1, 0)

# Extract actual class labels
actual_labels <- glm_df[[dep_var]]

# Calculate accuracy
accuracy <- mean(predicted_labels == actual_labels)
print(paste("Accuracy of the model:", accuracy))

# Optional: Detailed performance analysis
library(caret)
confusionMatrix(as.factor(predicted_labels), as.factor(actual_labels))
```


```{r}
library(boot)

# Check multicollinearity
vif_values <- vif(general_linear_model)
print(vif_values)

# Cross-validation
train_control <- trainControl(method = "cv", number = 10, classProbs = TRUE, savePredictions = "final")

# Fitting with cross-validation
model_cv <- train(formula = glm_formula, data = glm_df, method = "glm", family = binomial(), trControl = train_control, preProcess = "scale")
print(model_cv)

# Bootstrap resampling
boot_function <- function(data, indices) {
  data <- data[indices, ]
  fit <- glm(formula = glm_formula, data = data, family = binomial())
  predictions <- predict(fit, data, type = "response")
  labels <- ifelse(predictions > 0.5, 1, 0)
  mean(labels == data[[dep_var]])
}

boot_results <- boot(data = df, statistic = boot_function, R = 1000)
print(boot_results)
```


```{r}
# Generate LaTeX code with stargazer
stargazer::stargazer(general_linear_model, type = "latex",
          title = "Regression Results", align = TRUE,
          header = FALSE, single.row = TRUE, 
          column.labels = c("Estimate", "Std. Error"), 
          star.char.levels = c(0.01, 0.05, 0.1), 
          digits = 4,
          style = "default",  
          model.numbers = FALSE)  
```

```{r}

model_summary <- summary(general_linear_model)$coefficients

# Filtering for significant variables based on p-value threshold (e.g., p < 0.05)
significant_vars <- model_summary[model_summary[, 4] < 0.05, ]

# Sorting the significant variables by p-values 
sorted_model_summary <- significant_vars[order(significant_vars[, 4]),]

# Convert to xtable
latex_table <- xtable::xtable(sorted_model_summary)

# Print LaTeX code with four decimal places
print(latex_table, include.rownames = TRUE, floating = FALSE, digits = rep(6, ncol(sorted_model_summary)))
```







